node：用来运行js文件

# npm

* npm是什么
  1. nmp类似于maven，用在前端中，管理前端js依赖，联网下载js依赖，相当于前端的maven。

* npm项目初始化操作
  1. 使用命令npm init -y。
  2. 项目初始化之后，生成文件package.json，类似于后端的pom.xml文件。
* npm下载js依赖
  1. 命令 npm install 依赖名称。
  2. 设置taobao镜像npm config set registry https://registry.npm.taobao.org
  3. 查看npm配置npm config list。
  4. package-lock锁定当前版本。
  5. 下载指定版本npm install jquery@3.4.1

* 根据配置文件package.json下载依赖
  1. 使用命令npm install



# babel

* babel是什么

  1. Babel是转码器，把es6代码转换成es5代码。
  2. 因为写的代码es6代码，但是es6代码浏览器兼容性很差，如果使用es5代码浏览器兼容性很好。

* 安装Babel工具，使用命令

  1. npm install --global babel-cli

  2. 创建.babelrc配置文件

     ```babel
     {
         "presets": ["es2015"],
         "plugins": []
     }
     ```

     

  3. 安装es2015转码器npm install --save -dev babel -preset -es2015

  4. 使用命令转码

     ```babel
     babel es -d dist //将es下文件转成es5放入dist文件夹下
     ```

     

# 模块化

* 是什么

  1. 前端模块化，在前端中js与js之间调用称为前端模块化操作。  

     ```js
     //es5写法
     const sum = function (a, b) {
         return parseInt(a) + parseInt(b)
     }
     
     const subtract = function (a, b) {
         return parseInt(a) + parseInt(b)
     }
     
     //设置哪些方法可以被其他js调用
     module.exports = {
         sum,
         subtract
     }
     ```

     

     ```js
     //引入01.js文件
      const m = require('./01.js')
     
      //调用
      m.sum(1,2)
     ```



* es6模块化代码写法

  1. 如果使用es6写法实现模块化操作，在node.js环境中不能直接运行，需要使用Babel把es6转换es5代码，才可以在node.js进行运行

     ```js
     export function getList(){
     
         console.log('getList')
     }
     
     
     export default{
         getList(){
             console.log('getList')
         }
     }
     ```

     

     ```js
     
     //引入
     import { getList } from "./01";
     import m from "./01";
     //调用
     getList()
     
     m.getList()
     
     ```



# Webpack

* 什么是webpack 

  * 打包工具，可以把多个静态资源文件打包成一个文件，减少页面的请求。

* 全局安装

  * npm install -g webpack webpakc-cli

  * 创建js文件

    ```js
    exports.add = function (a, b) {
    
        return a + b;
    }
    ```

    ```js
    exports.info = function (str) {
        document.write(str);
    }
    ```

    ```
    const common = require('./common.js')
    const utils = require('./utils.js')
    ```

  * 创建webpack.config.js配置文件，配置打包信息

    ```js
    const path = require('path')//取路径
    module.exports = {
        entry: './src/main.js',//配置文件入口
        output: {
            path: path.resolve(__dirname, './dist'),//输出路径,_dirname:当前文件缩再路径 
            filename: 'bundle.js'//输出文件名
        }
    }
    ```

  * 使用命令执行打包操作

    `webpack`

    `webpack --mode=development`

* 打包css

  * 在main.js引入css文件

  * npm install --save -dev style-loader css-loader

  * 修改webpack.config.js

    ```js
    const path = require('path')//取路径
    module.exports = {
        entry: './src/main.js',//配置文件入口
        output: {
            path: path.resolve(__dirname, './dist'),//输出路径,_dirname:当前文件缩再路径
            filename: 'bundle.js'//输出文件名
        },
        module:{
            rules:[
                {
                    test:/\.css$/,//打包规则应用到css结尾的文件上
                    use: ['style-loader','css-loader']
                }
            ]
        }
    }
    ```

# 前端页面环境说明

* 前端框架入口
  * index.html
  * main.js
* 前端页面环境使用框架，基于两种技术vue+element-ui
* 框架build目录
  * 放项目构建的脚本文件
* config目录
  * index.js 修改userEslint:true，修改为false
  * dev.env.js修改访问后端接口地址
* src目录
  * api：目录定义调用方法
  * assets：静态资源
  * components：组件
  * icons：图标
  * router：路由
  * store：脚本文件
  * views：具体页面
* 修改配置文件请求地址
  * 在config文件夹里面有dev.env.js
  * 进行登录条用两个方法，login登录操作方法，和info登录之后获取用户信息的方法，所以，创建接口两个方法实现登录。
* 跨域问题
  * No 'Access-Control-Allow-Origin'
  * 通过一个地址去访问另外一个地址，这个过程中如果有三个地方任何一个不一样就会产生跨域
    * 访问协议  http https
    * ip地址
    * 端口号
  * 解决方式
    * 在后端接口controller添加注解
    * 使用网关解决

#  框架使用

* 添加路由

* 点击某个路由，显示路由对应页面内容

  * @/类似于./

  * 路由对应页面

  * component:() => import('@/views/tree/index') 

    ```js
    {
        path: '/teacher',
        component: Layout,
        redirect: '/teacher/table',//请求teacher时自动跳转这个请求
        name: '讲师管理',
        meta: { title: '讲师管理', icon: 'example' },
        children: [
          {
            path: 'table',
            name: '讲师列表',
            component: () => import('@/views/edu/teacher/list'),
            meta: { title: '讲师列表', icon: 'table' }
          },
          {
            path: 'save',
            name: '添加讲师',
            component: () => import('@/views/edu/teacher/save'),
            meta: { title: '添加讲师', icon: 'tree' }
          }
        ]
      },
    ```

    

* 在api文件夹创建js文件，定义接口地址

  ```js
  import request from '@/utils/request'
  
  export default {
      getTeacherListPage(current, limit, teacherQuery) {
          return request({
              //url: '/table/list/'+current+'/'+limit,
              url: `/eduservice/teacher/pageTeacherCondition/${current}/${limit}`,
              method: 'post',
              //teacherQuery条件对象，后端使用RequestBody获取数据
              //data表示把对象转换json进行传递到接口里面
              data: teacherQuery
          })
      }
  }
  ```

  

* 在创建vue页面引入js文件，调用方法实现功能

  * 在页面调用定义的接口方法，得到接口返回数据

    ```js
    <template>
      <div class="app-container">讲师列表</div>
    </template>
    
    <script>
    //引入调用文件
    import teacher from "@/api/edu/teacher";
    
    export default {
      //写核心代码位置
      // data:{
    
      // },
      data() {
        //定义变量和初始值
        return {
          list: null, //查询之后返回的结果
          page: 1,
          limit: 10,
          total: 0,
          teacherQuery: {},
        };
      },
      created() {
        //在页面渲染之前执行，一般调用methods定义的方法
        this.getList();
      },
      methods: {
        //创建具体的方法，调用teacher.js定义的方法
        getList() {
          teacher
            .getTeacherListPage(this.page, this.limit, this.teacherQuery)
            .then((response) => {
              //response接口返回的数据
              console.log(response);
            })
            .catch((error) => {
              console.log(error);
            });
        },
      },
    };
    </script>
    ```

    

  

  # 组件

  ```vue
  <!-- 表格 -->
      <el-table :data="list" border fit highlight-current-row>
      <el-table-column label="序号" width="70" align="center">
          <template slot-scope="scope">
          {{ (page - 1) * limit + scope.$index + 1 }}
          </template>
      </el-table-column>
        <el-table-column prop="name" label="名称" width="80" />
        <el-table-column label="头衔" width="80">
            <!-- scope代表表格每一行数据 -->
          <template slot-scope="scope">
            <!-- 三个===判断值和类型 -->
            {{ scope.row.level === 1 ? "高级讲师" : "首席讲师" }}
          </template>
        </el-table-column>
        <el-table-column prop="intro" label="资历" />
        <el-table-column prop="gmtCreate" label="添加时间" width="160" />
        <el-table-column prop="sort" label="排序" width="60" />
        <el-table-column label="操作" width="200" align="center">
          <template slot-scope="scope">
            <router-link :to="'/edu/teacher/edit/' + scope.row.id">
              <el-button type="primary" size="mini" icon="el-icon-edit"
                >修改</el-button
              >
            </router-link>
            <el-button
              type="danger"
              size="mini"
              icon="el-icon-delete"
              @click="removeDataById(scope.row.id)"
              >删除</el-button
            >
          </template>
        </el-table-column>
      </el-table>
  ```

  

  ```html
   <!-- 分页 -->
      <el-pagination
        :current-page="page"
        :page-size="limit"
        :total="total"
        style="padding: 30px 0; text-align: center;"
        layout="total, prev, pager, next, jumper"
        @current-change="fetchData"
      />
  ```

  ```vue
       <!--查询表单-->
      <el-form :inline="true" class="demo-form-inline">
        <el-form-item>
            <!-- 会在"this.teacherQuery自动添加name属性 数据 -->
          <el-input v-model="teacherQuery.name" placeholder="讲师名"/>
        </el-form-item>
        <el-form-item>
          <el-select v-model="teacherQuery.level" clearable placeholder="讲师头衔">
            <el-option :value="1" label="高级讲师"/>
            <el-option :value="2" label="首席讲师"/>
          </el-select>
        </el-form-item>
        <el-form-item label="添加时间">
          <el-date-picker
            v-model="teacherQuery.begin"
            type="datetime"
            placeholder="选择开始时间"
            value-format="yyyy-MM-dd HH:mm:ss"
            default-time="00:00:00"
          />
        </el-form-item>
        <el-form-item>
          <el-date-picker
            v-model="teacherQuery.end"
            type="datetime"
            placeholder="选择截止时间"
            value-format="yyyy-MM-dd HH:mm:ss"
            default-time="00:00:00"
          />
        </el-form-item>
        <el-button type="primary" icon="el-icon-search" @click="getList()">查询</el-button>
        <el-button type="default" @click="resetData()">清空</el-button>
      </el-form>
  ```

  

  * 会到列表页面 路由跳转

    ```js
      //路由跳转
     this.$router.push({ path: "/teacher/table" });
    ```

    

  * 隐藏路由

    ```js
      {
            path: 'edit/:id',//:id表示占位符 edit/12123 相当于where id = ?
            name: 'EduTeacherEdit',
            component: () => import('@/views/edu/teacher/save'),
            meta: { title: '编辑讲师', noCache: true },
            hidden: true
       }
    ```

    

  * 判断路径中有没有id值

    ```js
      created() {
        console.log('created')
        if (this.$route.params && this.$route.params.id) {
          const id = this.$route.params.id //从路径中获取id
          this.fetchDataById(id)
        }
      }
    ```

    

* 多次路由跳转到同一个页面，在页面中created方法只会执行第一次，后面在进行跳转不会执行的

  * 使用监听

    ```js
      watch: { //监听
        $route(to, from) { //路由变化方式，路由发生变化，方法执行
          console.log('watch $route')
          this.init()
        }
      },
    ```



# 对象存储OSS

* 开通对象存储OSS

* 阿里云oss管理控制台使用

  * 使用oss，收件创建bucket

* 使用java代码操作阿里云oss上传文件到阿里云oss操作

  * 创建操作阿里云oss许可证（阿里云颁发id和密钥）

    ```
    LTAI5t6Ck9eiAmZK4yri6Rg6
    NYFxh1D4BvsGjL8sqhRe2YKYpS9w2F
    
    ```

  * 创建启动类报错。启动时，找数据库配置，但是现在模块因为不需要操作数据库，只是上传到oss功能，没有配置数据库。

    ```txt
    Description:
    
    Failed to configure a DataSource: 'url' attribute is not specified and no embedded datasource could be configured.
    ```
    * 解决方式1：添加上数据配置

    * 解决方式2：在启动类添加数据，默认不去加载数据库配置

      ```java
      @SpringBootApplication(exclude = DataSourceAutoConfiguration.class)
      ```

  * 创建常量类，读取配置文件 

    ```java
    //当项目启动，spring接口，spring加载之后，执行一个接口的方法
    @Component
    public class ConstantPropertiesUtils implements InitializingBean {
    
        @Value("${aliyun.oss.file.endpoint}")
        private String endpoint;
    
        @Value("${aliyun.oss.file.keyid}")
        private String keyid;
    
        @Value("${aliyun.oss.file.keysecret}")
        private String keysecret;
    
        @Value("${aliyun.oss.file.bucketname}")
        private String bucketname;
    
    
        public static String END_POINT;
        public static String KEY_ID;
        public static String KEY_SECRET;
        public static String BUCKET_NAME;
    
        @Override
        public void afterPropertiesSet() throws Exception {
            KEY_ID=this.keyid;
            KEY_SECRET=this.keysecret;
            END_POINT=this.endpoint;
            BUCKET_NAME=this.bucketname;
        }
    }
    ```

    

  

  

  # nginx

* 反向代理服务器

* 请求转发

  * 根据请求转发到服务器中

* 负载均衡

  * 把请求平均分担到不同服务中去

* 动静分离

* 在nginx.conf进行配置

  * 修改nginx默认端口

  * 配置nginx转发规则

    * 在http{}里面创建配置

      ```config
        server {
      	listen       9001; #对外监听端口号
      	server_name  localhost;#主机
      
      
      	location ~ /eduservice/ { #匹配路径
      		proxy_pass http://localhost:8001; #转发服务器地址
      	}
      	location ~ /eduoss/ {
      		proxy_pass http://localhost:8002;
      	}
          }
      ```

      

# 组件使用

```js
import ImageCropper from "@/components/ImageCropper";
import PanThumb from "@/components/PanThumb";

```



```vue
 components: { ImageCropper, PanThumb }, //声明组件
```





# Excel导入导出

* EasyExcel操作excel进行读和写的操作

  ```java
  public class DemoData {
  
      //学生序号
      //设置excel表头名称
      //index代表excel表格字段索引
      @ExcelProperty(value = "学生序号",index = 0)
      private Integer sno;
  
      //学生名称
      //设置excel表头名称
      //index代表excel表格字段索引
      @ExcelProperty(value = "学生姓名",index = 1)
      private String sname;
  
  }
  
  ```

  

* 引入依赖

  ```pom
      <dependencies>
          <dependency>
              <groupId>com.alibaba</groupId>
              <artifactId>easyexcel</artifactId>
              <version>2.1.1</version>
          </dependency>
      </dependencies>
  ```

  * 写入excel

  ```java
      public static void main(String[] args) {
          String fileName = "D:\\excel\\write.xlsx";
  //参数1：文件名称
          //参数2：对应实体类
  //        EasyExcel
  //                .write(filename,DemoData.class)
  //                .sheet("学生列表")
  //                .doWrite(getLists());
          EasyExcel.write(fileName,DemoData.class).sheet("学生列表").doWrite(getData());
      }
  ```

  * 从excel中读取

    ```java
    public class ExcelListener extends AnalysisEventListener<DemoData> {
    
    
        //一行一行读取excel内容
        @Override
        public void invoke(DemoData demoData, AnalysisContext analysisContext) {
            System.out.println("***"+demoData);
        }
        //读取表头内容
        @Override
        public void invokeHeadMap(Map<Integer, String> headMap, AnalysisContext context) {
            System.out.println("表头"+headMap);
        }
        //读取完之后
        @Override
        public void doAfterAllAnalysed(AnalysisContext analysisContext) {
    
        }
    ```

    

    ```java
        public void test(){
            String fileName = "D:\\excel\\write.xlsx";
            EasyExcel.read(fileName,DemoData.class,new ExcelListener()).sheet().doRead();
        }
    ```

* 创建实体类和excel的对应关系

  ```java
      //一级分类
      //设置excel表头名称
      //index代表excel表格字段索引
      @ExcelProperty(index = 0)
      private String oneSubjectName;
  
      //二级分类
      @ExcelProperty(index = 1)
      private String twoSubjectName;
  ```

* 因为SubjectExcelLinstener不能交给spring进行管理，需要自己new，不能注入其他对象，不能实现数据库操作

  ```java
  public class SubjectExcelListener extends AnalysisEventListener<SubjectData> {
  
      //因为SubjectExcelListener態交给spring进行ioc管理，需要自己手动new，不能注入其他对象
      //不能实现数据库操作

      public EduSubjectService eduSubjectService;
  
      //有参，传递subjectService用于操作数据库
      public SubjectExcelListener(EduSubjectService eduSubjectService) {
          this.eduSubjectService = eduSubjectService;
      }
  
      //无参
      public SubjectExcelListener() {
      }
  
      //读取excel内容，一行一行读取
      @Override
      public void invoke(SubjectData subjectData, AnalysisContext analysisContext) {
          //表示excel中没有数据，就不需要读取了
          if (subjectData==null){
              throw new AchangException(20001,"添加失败");
          }
  
          //一行一行读取，每次读取有两个值，第一个值一级分类，第二个值二级分类
          //判断是否有一级分类是否重复
          EduSubject existOneSubject = this.existOneSubject(eduSubjectService, subjectData.getOneSubjectName());
          if (existOneSubject == null){ //没有相同的一级分类，进行添加
              existOneSubject = new EduSubject();
              existOneSubject.setParentId("0"); //设置一级分类id值，0代表为一级分类
              existOneSubject.setTitle(subjectData.getOneSubjectName());//设置一级分类名
              eduSubjectService.save(existOneSubject);//给数据库添加一级分类
          }
  
          //获取一级分类的id值
          String parent_id = existOneSubject.getId();
          //判断是否有耳机分类是否重复
          EduSubject existTwoSubject = this.existTwoSubject(eduSubjectService, subjectData.getTwoSubjectName(), parent_id);
          if (existTwoSubject==null){//没有相同的二级分类，进行添加
              existTwoSubject = new EduSubject();
              existTwoSubject.setParentId(parent_id); //设置二级分类id值
              existTwoSubject.setTitle(subjectData.getTwoSubjectName());//设置二级分类名
              eduSubjectService.save(existTwoSubject);//给数据库添加二级分类
          }
  
      }
  
  
      //判断一级分类不能重复添加
      private EduSubject existOneSubject(EduSubjectService eduSubjectService,String name){
          QueryWrapper<EduSubject> wrapper = new QueryWrapper<>();
          wrapper.eq("title",name)
                  .eq("parent_id","0");
          EduSubject oneSubject = eduSubjectService.getOne(wrapper);
          return oneSubject;
      }
  
      //判断二级分类不能重复添加
      private EduSubject existTwoSubject(EduSubjectService eduSubjectService,String name,String parentId){
          QueryWrapper<EduSubject> wrapper = new QueryWrapper<>();
          wrapper.eq("title",name)
                  .eq("parent_id",parentId);
          EduSubject twoSubject = eduSubjectService.getOne(wrapper);
          return twoSubject;
      }
  
      @Override
      public void doAfterAllAnalysed(AnalysisContext analysisContext) {
  
      }
  }
  ```
  
  

# 表单提交

```vue
<template>
  <div class="app-container">
    <el-form label-width="120px">
      <el-form-item label="信息描述">
        <el-tag type="info">excel模版说明</el-tag>
        <el-tag>
          <i class="el-icon-download" />

          <a :href="'/static/01.xlsx'">点击下载模版</a>
        </el-tag>
      </el-form-item>
      <el-form-item label="选择Excel">
        <!-- ref表示唯一标识 类似于HTML中id属性 
        limit每次只能传一个文件
        name=file就是<input type=file name="file">-->
        <el-upload
          ref="upload"
          :auto-upload="false"
          :on-success="fileUploadSuccess"
          :on-error="fileUploadError"
          :disabled="importBtnDisabled"
          :limit="1"
          :action="BASE_API + '/eduservice/subject/addsubject'"
          name="file"
          accept="application/vnd.ms-excel"
        >
          <el-button slot="trigger" size="small" type="primary"
            >选取文件</el-button
          >
          <el-button
            :loading="loading"
            style="margin-left: 10px"
            size="small"
            type="success"
            @click="submitUpload"
            >上传到服务器</el-button
          >
        </el-upload>
      </el-form-item>
    </el-form>
  </div>
</template>
```



```js

    submitUpload(){
      this.fileUploadBtnText = '正在上传'
      this.importBtnDisabled = true
      this.loading = true
      //js:document.getElementById("upload").submit()
      this.$refs.upload.submit()
    },
```

# 表说明

* edu_course：课程表，存储课程基本信息
* edu_course_descriprion：课程简介表：存储课程简介信息
* edu_chapter：课程章节表，存储课程章节信息
* edu_video：存储章节里面小节信息
* edu_teacher：讲师表
* edu_subject：分类表

# 注册change事件

* 当值发生改变事件触发

```html
<el-select @change="subjectLevelOneChanged" ......
```

```js
 subjectLevelOneChanged(value) {
      //value就是标签的value值
      for(var i=0;i<subjectOneList.length;i++){
        //获取每个以及对象
        var oneSubject =  subjectOneList[i];
        //判断每个一级对象的id和事件id
        if(oneSubject.id === value){
          //从一级分类里面获取所有的二级分类
          this.subjectTwoList = oneSubject.children
        }
      }
    }
```



# 样式

```css
只在当前页面有效
<style scoped>
.tinymce-container {
  line-height: 29px;
}
</style>
```

# mybatis中实体类与数据表如何对应

* 先根据xxxMapper.xml中的sql语句判断是哪个数据表

* 然后又利用 resultMap中的type来判断是哪个实体类
* 然后在把表的字段与实体类的字符对应即可

# 403状态码

* 跨域
* 路径写作

# mysql多表查询

* 内连接：查询两张表有关联的数据

* 左外连接：左边表所有数据都查询出来，右边表只查询关联

* 有关链接：同上

  ```mysql
      <select id="getPublishCourseInfo" resultType="com.atguigu.eduservice.entity.vo.CoursePublishVo">
          select ec.id,ec.title,ec.price,ec.lesson_num as lessonNum,
                 et.name as teacherName,
                 es1.title as subjectLevelOne,
                 es2.title as subjectLevelTwo
          from edu_course ec left outer join edu_course_description ecd on ec.id=ecd.id
                             left outer join edu_teacher et on ec.teacher_id=et.id
                             left outer join edu_subject es1 on ec.subject_parent_id=es1.id
                             left outer join edu_subject es2 on ec.subject_id=es2.id
                             where ec.id=#{courseId}
                             <!--当mapper中只有一个参数，传过来的值可以随便写-->
      </select>
  ```

  

# 错误

* batis.binding.BindingException: Invalid bound statement (not found)
* 这个错误是有maven默认加载机制造成问题
* maven加载时候，把java文件夹里面.java类型文件进行编译，如果其他类型文件，不会加载





* 解决方式

  1. 复制xml到target目录中

  2. 把xml放到resource目录中

  3. 推荐使用：通过配置实现

     1. pom.xml

        ```xml
            <build>
                <resources>
                    <resource>
                        <directory>src/main/java</directory>
        <!--                文件夹下进行包含加载-->
                        <includes>
                            <include>**/*.xml</include>
                        </includes>
                        <filtering>false</filtering>
                    </resource>
                </resources>
            </build>
        ```

        

     2. 项目application.properties

        ```properties
        #配置mapper xml文件的路径
        mybatis-plus.mapper-locations=classpath:com/guli/edu/mapper/xml/*.xml
        ```

        

# 阿里云

* API：阿里云提供固定的地址，只需要调用这个固定地址，想地址传递参数，实现功能
  * http(s)://vod.cn-shanghai.aliyuncs.com/?Action=GetPlayInfo
  * httpclient技术可以调用api地址
* SDK：对api方式进行封装，更方便使用
  
* 调用阿里云提供类或者接口里面的方法实现视频功能
  
* 获取视频播放地址
  
  * 因为上传视频可以进行加密，加密之后，使用加密之后地址不能进行播放，在数据库存储不存储地址，而是存储视频id
* 获取视频播放凭证
* 上传视频到阿里云视频点播服务

* 引入上传依赖，但是这个依赖不能在maven中央仓库下载到，手动把依赖安装到本地仓库里面

  * 使用maven命令进行安装

    ```cmd
    mvn install:install-file -DgroupId=com.aliyun -DartifactId=aliyun-sdk-vod-upload -Dversion=1.4.11 -Dpackaging=jar -Dfile=aliyun-java-vod-upload-1.4.11.jar
    ```

    

```java
 public static void getPlayAuth()throws ClientException{
        //根据视频id获取视频播放凭证
        DefaultAcsClient client = InitObject.initVodClient("LTAI5t6Ck9eiAmZK4yri6Rg6", "NYFxh1D4BvsGjL8sqhRe2YKYpS9w2F");
        //创建获取视频凭证request和response
        GetVideoPlayAuthRequest request = new GetVideoPlayAuthRequest();
        GetVideoPlayAuthResponse response = new GetVideoPlayAuthResponse();

        request.setVideoId("b8c70c3689f947acb640a79a65956023");
        //向request设置视频id
        response = client.getAcsResponse(request);
        System.out.println(response.getPlayAuth());



    }
```

```java
public static void getPlayUrl()throws Exception{
        //根据视频id获取视频播放地址

        //创建初始化对象
        DefaultAcsClient client = InitObject.initVodClient("LTAI5t6Ck9eiAmZK4yri6Rg6", "NYFxh1D4BvsGjL8sqhRe2YKYpS9w2F");
        //创建获取视频地址request和response
        GetPlayInfoRequest request = new GetPlayInfoRequest();
        GetPlayInfoResponse response = new GetPlayInfoResponse();

        //向request对象里面设置视频id
        request.setVideoId("b8c70c3689f947acb640a79a65956023");
        //调用初始化对象里面的方法，传递request，获取数据
        response = client.getAcsResponse(request);

        List<GetPlayInfoResponse.PlayInfo> playInfoList = response.getPlayInfoList();
        //播放地址
        for (GetPlayInfoResponse.PlayInfo playInfo : playInfoList) {
            System.out.print("PlayInfo.PlayURL = " + playInfo.getPlayURL() + "\n");
        }
        //Base信息
        System.out.print("VideoBase.Title = " + response.getVideoBase().getTitle() + "\n");

    }
```

* InitializingBean：当项目已启动，spring加载后，执行接口一个方法

* Caused by: java.lang.IllegalStateException: org.apache.tomcat.util.http.fileupload.FileUploadBase$FileSizeLimitExceededException

  * 超出大小

    ```prope
    # 最大上传单个文件大小：默认1M
    #spring.servlet.multipart.max-file-size=1024MB
    # 最大置总上传的数据大小 ：默认10M
    #spring.servlet.multipart.max-request-size=1024MB
    ```

    

* nginx问题

  * 需要在nginx配置8003端口规则

  * nginx支持上传大小有限制的

  * 错误：POST http://localhost:9001/eduvod/video/uploadAliyunVideonet::ERR_FAILED 413(Request Entity Too Large) 

    * 413请求体过大

  * 解决：在nginx配置文件中添加大小设置

    * 

      ```
      client_max_body_size 1024m;
      ```

  

# 微服务

* 微服务是什么
  * 微服务时架构风格
  * 把一个项目拆分成多个服务，多个服务时独立运行，每个服务占用独立进程

* SpringCloud

  * springcloud并不是一种技术，是很多技术总称，很多技术集合
  * springcloud里面有很多框架，
  * 使用springcloud，需要依赖技术springboot

* springcloud相关基础服务组件

  * 服务发现——Netflix Eureka（nacos）
  * 服务调用——Netflix Fegin
  * 熔断器——Netflix Hystrix
  * 服务网关——spring Cloud GeteWay
  * 分布式配置——spring cloud config
  * 消息总线——spring Cloud bus

* 小版本

  * SNAPSHOT：快照版本，随时可能修改
  * M：MileStone，M1表示第1个里程碑版本，一般同时标注PRE，表示预览版本
  * SR：Service Release，SR1表示第一个正式版本，一般同时标注GA：GenerallyAvailable，表示稳定版本 

* nacos

  * 引入依赖在service的pom文件中

  * 在注册的服务的配置文件中application.properties进行配置nacos地址

    ```properties
    #nacos服务地址
    spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
    ```

  * 在启动类添加注解

* feign

  * 引入依赖

  * 在启动类添加注解

  * 在调用端 创建interface，使用注解指定调用服务名称，定义调用的方法路径

    ```java
    @Component
    @FeignClient("service-vod")//调用的服务名称
    public interface VodClient {
    
        //定义调用方法的路径
        @DeleteMapping("/eduvod/video/removeAlyVideo/{id}")
        //@PathVariable注解一定要指定参数名称，否则出错
        public R removeAlyVideo(@PathVariable("id") String id);
    }
    ```

    

* 错误

  * 泛型没有定义

  ```java
  org.springframework.web.bind.annotation.RequestParam java.util.List<?>. Not declared?
  ```


* spring cloud 在接口调用上，大致会经过如下几个组件配和：Feign->Hystrix->Ribbon->Http Client
  * Feign：找到服务中接口调用
  * Hystrix：当生产者服务器宕机，就会进行熔断机制，不在请求
  * Ribbon：对请求做负载均衡
  * Http Client：发送请求

* Hystrix

  * 第一步添加熔断器依赖

    ```xml
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
            </dependency>
            <!--hystrix依赖，主要是用 @HystrixCommand -->
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
            </dependency>
    ```

  * 在调用端配置文件中开启熔断器

    ```properties
    #开启熔断机制
    feign.hystrix.enabled=true
    #设置hystrix超时时间，默认1000ms
    #hystrix.metrics.polling-interval-ms=6000
    ```

  * 在创建interface之后，还需要创建interface对应实现类，在实现类实现方法，出错了输出内容

    ```java
    @Component
    public class VodFileDegradeFeignClient implements VodClient {
        //出错之后会执行
    
        @Override
        public R removeAlyVideo(String id) {
            return R.error().message("删除视频出错了");
        }
    
        @Override
        public R deleteBatch(List<String> videoIdList) {
            return  R.error().message("删除多个视频出错了");
        }
    }
    ```

    

  * 在interface上面添加注解和属性

    ```java
    @Component
    @FeignClient(name = "service-vod",fallback = VodFileDegradeFeignClient.class)
    public interface VodClient {
        //定义调用方法的路径
        @DeleteMapping("/eduvod/video/removeAlyVideo/{id}")
        public R removeAlyVideo(@PathVariable("id") String id);
    
    
        //定义调用删除多个视频的方法
        @DeleteMapping("/eduvod/video/delete-batch")
        public R deleteBatch(@RequestParam("videoIdList") List<String> videoIdList);
    }
    
    ```




# 搭建前台框架

* 使用NUXT框架搭建前台环境

* 服务端渲染技术
  
  * ajax请求：不利于SEO
  
* NUXT目录结构
  * .nuxt：编译之后的文件
  * assets：一般放项目的静态资源，比如css、js、img
  * components：放项目使用相关组件
  * layouts：定义网页布局的方式（default.vue设置布局头和尾，中间引入pages下的index.vue）
  * pages：项目页面(需要在page文件下页面script中使用(layout:"index")指定layouts文件下头和尾的页面)
  * nuxt.config.js：核心配置文件

* 整合项目页面

  * 安装幻灯片插件

    ```npm
    npm install vue-awesome-swiper
    ```

  * 在plugins文件下新建nuxt-swiper-plugin.js配置

    ```js
    import Vue from 'vue'
    import VueAwesomeSwiper from 'vue-awesome-swiper/dist/ssr'
    Vue.use(VueAwesomeSwiper)
    ```

    

  * 在nuxt.config.js文件中配置插件，将plugins和css节点复制到module.exports节点下

    ```js
    module.exports = {
    
      plugins: [
        { src: '~/plugins/nuxt-swiper-plugin.js', ssr: false }
      ],
      css: [
        'swiper/dist/css/swiper.css'
      ],
    ```

    

* nuxt路由

  * 固定路由：路径是固定地址，不发生变化(在pages里面创建文件夹course，在course文件夹，创建index.vue)

    ```vue
    <!--to属性设置路由跳转地址-->        
    <router-link to="/" tag="li" active-class="current" exact>
                  <a>首页</a>
              </router-link>
    ```

    

  * 动态路由：每次生成路由地址不一样，比如课程详情页面，每个课程id不一样

    * 如果我们需要id查询一条记录，就需要动态路由。NUXT的动态路由是以下划线开头的vue文件，参数名为下划线后边的文件名。（_id.vue）
  
* 封装axios

  ```js
  import axios from 'axios'
  
  // 创建axios实例
  const service = axios.create({
      baseURL: 'http://localhost:9001', // api 的 base_url
      timeout: 20000 // 请求超时时间
    })
  
  //可以被别的地方引用
    export default service
  ```


# Redis

* redis
  * 基于key-value进行存储的
  * 支持多种数据结构：string（字符串）；list（列表）；hash（哈希），set（集合）；zset(有序集合)   
  * 支持持久化，通过内存进行存储的，也可以存到硬盘里面
  * 支持过期时间，支持事务，消息订阅
* 一般来讲，把经常进行查询，不经常修改，不是特别重要的数据放到redis作为缓存

* 添加redis缓存

  * 创建redis配置类

    * 引入springboot整合redis相关依赖

      ```xml
              <!-- redis -->
              <dependency>
                  <groupId>org.springframework.boot</groupId>
                  <artifactId>spring-boot-starter-data-redis</artifactId>
              </dependency>
      
              <!-- spring2.X集成redis所需common-pool2 -->
              <dependency>
                  <groupId>org.apache.commons</groupId>
                  <artifactId>commons-pool2</artifactId>
                  <version>2.6.0</version>
              </dependency>
      
      ```

      

    * 创建redis缓存配置类，配置插件

      ```java
      @EnableCaching
      @Configuration
      public class RedisConfig extends CachingConfigurerSupport {
      
          @Bean
          public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
              RedisTemplate<String, Object> template = new RedisTemplate<>();
              RedisSerializer<String> redisSerializer = new StringRedisSerializer();
              Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
              ObjectMapper om = new ObjectMapper();
              om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
              om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
              jackson2JsonRedisSerializer.setObjectMapper(om);
              template.setConnectionFactory(factory);
              //key序列化方式
              template.setKeySerializer(redisSerializer);
              //value序列化
              template.setValueSerializer(jackson2JsonRedisSerializer);
              //value hashmap序列化
              template.setHashValueSerializer(jackson2JsonRedisSerializer);
              return template;
          }
      
          @Bean
          public CacheManager cacheManager(RedisConnectionFactory factory) {
              RedisSerializer<String> redisSerializer = new StringRedisSerializer();
              Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
              //解决查询缓存转换异常的问题
              ObjectMapper om = new ObjectMapper();
              om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
              om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
              jackson2JsonRedisSerializer.setObjectMapper(om);
              // 配置序列化（解决乱码的问题）,过期时间600秒
              RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
                      .entryTtl(Duration.ofSeconds(600))
                    .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))
                      .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))
                      .disableCachingNullValues();
              RedisCacheManager cacheManager = RedisCacheManager.builder(factory)
                      .cacheDefaults(config)
                      .build();
              return cacheManager;
          }
      }
      
      ```

  * 缓存@Cacheable：根据方法对其返回结果进行缓存，下次请求时，如果缓存存在，则直接读取缓存数据返回；如果缓存不存在，则执行方法，并把返回的结果存入缓存中。一般用在查询方法上。

    * value：缓存名，必填，它指定了你的缓存存放在哪块命名空间
    * cacheNames：与 value 差不多，二选一即可
    * key：可选属性，可以使用 SpEL 标签自定义缓存的key

  * 缓存@CachePut：使用该注解标志的方法，每次都会执行，并将结果存入指定的缓存中。其他方法可以直接从响应的缓存中读取缓存数据，而不需要再去查询数据库。一般用在新增方法上。

  * 缓存@CacheEvict：使用该注解标志的方法，会清空指定的缓存。一般用在更新或者删除方法上

    * allEntries：是否清空所有缓存，默认为 false。如果指定为 true，则方法调用后将立即清空所有的缓存
    * beforeInvocation：是否在方法执行前就清空，默认为 false。如果指定为 true，则在方法执行前就会清空缓存

  * 添加redis配置

    ```properties
    #redis配置
    spring.redis.host=192.168.44.132
    spring.redis.port=6379
    spring.redis.database= 0
    spring.redis.timeout=1800000
    
    spring.redis.lettuce.pool.max-active=20
    spring.redis.lettuce.pool.max-wait=-1
    #最大阻塞等待时间(负数表示没限制)
    spring.redis.lettuce.pool.max-idle=5
    spring.redis.lettuce.pool.min-idle=0
    
    ```

    

# 登录

* 单一服务器模式
  * 使用session对象实现
    * 登录成功之后，把用户数据放到session里面
    * 判断是否登录，从session获取数据，可以获取到登录
* 单点登录：在任何一个模块登录之后，其他模块不需要登录
* SSO（single sign on）模式
* 单点登录三种常见方式
  * 第一种：session广播机制实现
    * session复制
  * 第二种：使用cookie + redis实现
    * 在项目中任何一个模块进行登录，登录之后，把数据放到两个地方
    * redis：在key：生成唯一随机值（ip、用户id等等），在value：用户数据
    * cookie：把redis里面生成key值放到cookie里面
    * 访问项目中其他模块，发送请求带着cookie进行发送，获取cookie值，拿着cookie做事情
    * 把cookie获取值，到redis进行查询，根据key进行查询，如果查询数据就是登录
  * 第三种：使用token实现
    * token：按照一定规则生成字符串，字符串可以包含用户信息
    * 在项目某个模块进行登录，登录之后，按照规则生成字符串，把登录之后用户包含到生成字符串里面
      * 可以把字符串通过cookie返回
      * 把字符串通过地址栏返回
    * 再去访问项目其他模块，每次访问在地址栏带着生成字符串，在访问模块里面获取地址栏字符串，根据字符串获取用户信息。如果可以获取到，就是登录

# JWT

* token 是按照一定规则生成字符串，包含用户信息。规则是怎么样的，不一定，一般采用通用的规则，官方规则，JWT就是给我们是规定好了规则，使用jwt规则可以生成字符串，包含用户信息

* JWT生成字符串包含三部分

  * 第一部分：jwt头信息

    ```json
    {
      "alg": "HS256",
      "typ": "JWT"
    }
    ```

    

  * 第二部分：有效载荷，包含主体信息（用户信息）

    ```js
    iss：发行人
    exp：到期时间
    sub：主题
    aud：用户
    nbf：在此之前不可用
    iat：发布时间
    jti：JWT ID用于标识该JWT
    ```

  * 第三部分：签名哈希 防伪标志

    ```js
    HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(claims), secret)
    ```

    

# 阿里云短信服务

* 开通阿里云短信服务

* 进入控制台，点击国内消息，需要申请两个内容（签名管理，模板管理）

* 申请模板管理

* 申请签名管理

  ```java
    public boolean send(Map<String, Object> param, String phone) {
  
          if(StringUtils.isEmpty(phone)) return false;
  
          DefaultProfile profile =
                  DefaultProfile.getProfile("default", "LTAI5t6Ck9eiAmZK4yri6Rg6", "NYFxh1D4BvsGjL8sqhRe2YKYpS9w2F");
          IAcsClient client = new DefaultAcsClient(profile);
  
  
          CommonRequest request = new CommonRequest();
          //request.setProtocol(ProtocolType.HTTPS);
          request.setMethod(MethodType.POST);
          request.setDomain("dysmsapi.aliyuncs.com");//请求阿里云哪里，默认不能改
          request.setVersion("2017-05-25");
          request.setAction("SendSms");//请求哪个方法
  
  
  
          request.putQueryParameter("PhoneNumbers",phone);//设置要发送的【手机号】
          request.putQueryParameter("SignName","阿里云短信测试");//申请阿里云短信服务的【签名名称】
          request.putQueryParameter("TemplateCode","SMS_154950909");//申请阿里云短信服务的【模版中的 模版CODE】
  
          //要求传递的code验证码为jason格式，可以使用JSONObject.toJSONString()将map转为json格式
          request.putQueryParameter("TemplateParam", JSONObject.toJSONString(param));
  
  
          //最终发送
          try {
              CommonResponse response = client.getCommonResponse(request);
              return response.getHttpResponse().isSuccess();
          } catch (ClientException e) {
              e.printStackTrace();
              return false;
          }
  
      }
  ```

  

# @Mapper与@MapperScan

- 给每个dao接口上都加上@Mapper，它就会将mapper自动注入进spring容器。
- 在主启动类上加入@MapperScan，指定要扫描（dao接口）包的路径

# 错误

```java
org.springframework.http.converter.HttpMessageNotReadableException: Required request body is missing: public com.atguigu.commonutils.R com.atguigu.educenter.controller.UcenterMemberController.loginUser(com.atguigu.educenter.entity.UcenterMember)
```

* 使用Requestbody时候需要post提交，如果get提交出现上面错误

# 在nuxt中环境中安装插件

* 执行命令安装

  `npm install element-ui`

* 修改配置文件nunx-swiper-plugin.js

  ```js
  import Vue from 'vue'
  import VueAwesomeSwiper from 'vue-awesome-swiper/dist/ssr'
  import VueQriously from 'vue-qriously'
  import ElementUI from 'element-ui' //element-ui的全部组件
  import 'element-ui/lib/theme-chalk/index.css'//element-ui的css
  Vue.use(ElementUI) //使用elementUI
  Vue.use(VueQriously)
  Vue.use(VueAwesomeSwiper)
  
  ```

  





# 页面实现倒计时效果，使用js定时器

```js
<script>
    setInterval("alert('test')",3000);
 </script>   
```





# 登录成功之后首页显示数据实现过程分析

* 调用接口登录返回token字符串

* 把第一步返回token字符串放到cookie里面

  ```js
        //把token存在cookie中、也可以放在localStorage中
  		//参数1：cookie名
  		//参数2：cookie值
  		//参数3：作用范围
        cookie.set('guli_token', this.token, {domain: 'localhost'})
  ```

  

* 创建前端拦截器

  * 判断cookie里面是否有token字符串，如果有，把 token字符串放到header（请求头）

    ```js
    import request from '@/utils/request'
    
    // 创建axios实例
    const service = axios.create({
        baseURL: 'http://localhost:9001', // api 的 base_url
        timeout: 20000 // 请求超时时间
    })
    
    //每次发送请求中使用拦截器
    service.interceptors.request.use(
        config => {
        //debugger
        //判断cookie里面是否有guli_token的数据
        if (cookie.get('guli_token')) {
            //获取到的请求值放到header中
          config.headers['token'] = cookie.get('guli_token');
        }
          return config
        },
        err => {
        return Promise.reject(err);
      })
    
    export default service
    ```

    

* 根据token值，调用接口，根据token获取用户信息，为了首页面显示

  * 返回的用户信息放到cookie

    ```js
    //跳转页面
    window.location.href = "/";
    ```

    

* 在首页显示用户信息
  
  * 从cookie获取用户信息
  
    * 从cookie中取出的字符串需要转换
  
      ```js
       showInfo() {
            var userStr = cookie.get("guli_ucenter");
            //把字符串转换成json数据格式
            //"{'name':'lucy'}"转换成{'name':'lucy'}
            if (userStr) {
              this.loginInfo = JSON.parse(userStr);
            }
          },
      ```
  
      

# 微信扫描登陆

* OAuth2
  * 是针对特定问题一种解决方案
    * 方式一：用户名密码复制：适用于同一公司内部的多个系统，不适用于不受信的第三方应用
    * 方式二：通用开发者key：适用于合作商或者授信的不同业务部门之间
    * 方式三：办法令牌：接近OAuth2方式，需要考虑如何管理令牌、颁发令牌、吊销令牌，需要统一的协议，因此就有了OAuth2协议
  * OAuth2主要可以解决两个问题
    1. 开放系统间授权
    2. 分布式访问问题
       * 登录成功之后，按照一定规则生成字符串，字符串包含用户信息
       * 把生成的字符串通过路径传递，或者cookie
       * 后面在发送请求的时候，每次带着字符串进行发送，获取字符串，从字符串获取用户登录信息
  * 解决方案：令牌机制，按照一定规则生成字符串，字符串包含用户信息
  * OAuth2.0误解
    * OAuth并没有支持HTTP以外的协议
    * OAuth并不是一个认证协议
    * OAuth并没有定义授权处理机制
    * OAuth并没有定义token格式
    * OAuth2.0并没有定义加密方法
    * OAuth2.0并不是单个协议
    * OAuth2.0仅是授权框架，仅用于授权代理

* 微信扫描登录准备
  * 注册开发者资质
    * 支持企业类型
    * 注册之后，提供微信id和微信密钥
  * 申请网站应用名称
  * 需要域名地址



* 步骤

  * 配置文件中，添加微信id、密钥和域名地址

    ```properties
    # 微信开放平台 appid
    wx.open.app_id=wxed9954c01bb89b47
    # 微信开放平台 appsecret
    wx.open.app_secret=a7482517235173ddb4083788de60b90e
    # 微信开放平台 重定向url
    wx.open.redirect_url=http://guli.shop/api/ucenter/wx/callback
    ```

  * 创建类读取配置文件内容

    ```java
    package com.guli.ucenter.util;
    
    @Component
    //@PropertySource("classpath:application.properties")
    public class ConstantPropertiesUtil implements InitializingBean {
    
        @Value("${wx.open.app_id}")
        private String appId;
    
        @Value("${wx.open.app_secret}")
        private String appSecret;
    
        @Value("${wx.open.redirect_url}")
        private String redirectUrl;
    
        public static String WX_OPEN_APP_ID;
        public static String WX_OPEN_APP_SECRET;
        public static String WX_OPEN_REDIRECT_URL;
    
        @Override
        public void afterPropertiesSet() throws Exception {
            WX_OPEN_APP_ID = appId;
            WX_OPEN_APP_SECRET = appSecret;
            WX_OPEN_REDIRECT_URL = redirectUrl;
        }
    }
    
    ```

  * 生成微信扫描二维码

    * 直接请求微信提供固定的地址，向地址后面拼接参数

      ```java
      //使用占位符对字符串赋值
              // 微信开放平台授权baseUrl
              String baseUrl = "https://open.weixin.qq.com/connect/qrconnect" +
                      "?appid=%s" +
                      "&redirect_uri=%s" +
                      "&response_type=code" +
                      "&scope=snsapi_login" +
                      "&state=%s" +
                      "#wechat_redirect";
      
              String url = String.format(
                      baseUrl,
                      ConstantWxUtils.WX_OPEN_APP_ID,
                      ConstantWxUtils.WX_OPEN_REDIRECT_URL,
                      "atguigu"
              );
      ```

      

* 微信扫描二维码
  * 调用配置域名地址
  * 在域名地址里面，写程序，做了处理
  * 直接请求地址，通过这个到本地
  * 需要做两件事
    * 把本地服务端口号改成8150
    * 回调接口地址和域名跳转地址写成一样

* 步骤

  * 扫描之后，执行本地的callback方法，在从callback获取两个值，在跳转时候传递过来

    * state：原样传递

    * code：类似于手机验证码，随机唯一的值(临时票据)

      ```java
          //获取扫描人信息，添加数据
          @GetMapping("/callback")
          public String callback(String code,String state){
              System.out.println(code);
              System.out.println(state);
              return "redirect:http://localhost:3000";
          }
      
      ```

      

  * 拿着第一步获取到的code值，请求微信提供固定的地址，获取到两个值

    * access_token：访问凭证

    * openid：每个微信唯一标识

      ```json
      {"access_token":"59_Vf3AUK3I14WzD6BzyyIgpjPpfg0ktNS8i77kPjAG2F6ELPDWJj9tWfo4V51DnS9RqJUmLrJE2V6NzQSEXgNZZVcdUiB_Rbn3kSLXyFkNd2s","expires_in":7200,"refresh_token":"59_4azFz-zhimJg0JlbIv6oy_0fy3yO3LM7cjohSL13ADurl8Myt8jJAq-4WMefDA--2NFnQAo4h35n6UfmE03408aRehRMN9jtEKH3Adeycl0","openid":"o3_SC5-EbylhG65KTOKW-mMP2g_k","scope":"snsapi_login","unionid":"oWgGz1J_UA_fDrngwxOfgJ0iwONc"}
      
      ```

      

  * 拿着第二部获取到两个值access_token和openid，再去请求一个微信提供固定地址，最终可以得到微信扫描人信息。比如微信昵称，微信头像等

    ```json
    {"openid":"o3_SC5-EbylhG65KTOKW-mMP2g_k","nickname":"小不牛","sex":0,"language":"","city":"","province":"","country":"","headimgurl":"https:\/\/thirdwx.qlogo.cn\/mmopen\/vi_32\/Q0j4TwGTfTKKd87oVpCf0NlhjcZ8MpB0ARwQrdj43LObn2BkqROpsJ5tyThkcKNQzm2bl7rFicEMsMkPm5K48sw\/132","privilege":[],"unionid":"oWgGz1J_UA_fDrngwxOfgJ0iwONc"}
    
    ```

    

* 技术点
  * httpClient
  * json转换工具
    * fastjson
    * gson
    * jackson

# 问题

* 如果把扫描数据放到cookie中有问题
  * 因为cookie无法实现跨域访问
* 根据微信信息使用jwt，生成token字符串，把token字符串通过路径传递到首页面

# 路径取值

* localhost:6000/edit/123
  * this.$route.params.id
* localhost:3000/?token=eyJ0eXAiOiJKV1QiLCJhb
  * this.$route.query.token





# 调用

```js
//异步调用 进入页面需要发送请求 只会调用一次
//error:得到当前调用的错误信息
//params:相当于之前 this.$route.params.id 等价 params.id（id是_id）
export default {
   return teacherApi.getTeacherList(1,8)
    .then(response => {
        return {data(data可以自定义名称):response.data.data}
    })

  },
};
```

* 函数

  ```js
  //Number表示变成数字进行判断   
  <span class="fr jgTag bg-green" v-if="Number(item.price) === 0">
  ```

  

# 样式

```vue
//两个值相等，样式active生效
:class="{ active: twoIndex == index }"

<style scoped>
.active {
  background: #bdbdbd;
}
.hide {
  display: none;
}
.show {
  display: block;
}
</style>
```

* v-html：将内容中的html标签翻译出来，在{{}}里面做显示

  ```vue
   <p v-html="courseWebVo.description">
  {{ courseWebVo.description }}</p>
  ```

  

# 视频播放

* 引入文件

  ```html
  <link rel="stylesheet" href="https://g.alicdn.com/de/prismplayer/2.8.1/skins/default/aliplayer-min.css" />
  <script charset="utf-8" type="text/javascript" src="https://g.alicdn.com/de/prismplayer/2.8.1/aliplayer-min.js"></script>
  
  ```

  

* 初始化视频播放器

  ```html
  <body>
      <div  class="prism-player" id="J_prismPlayer"></div>
      <script>
          var player = new Aliplayer({
              id: 'J_prismPlayer',
              width: '100%',
              autoplay: false,
              cover: 'http://liveroom-img.oss-cn-qingdao.aliyuncs.com/logo.png',  
              //播放配置
          },function(player){
              console.log('播放器创建好了。')
          });
      </script>
  </body>
  
  ```

  

* 设置播放地址

  ```html
  //播放方式一：支持播放地址播放,此播放优先级最高，此种方式不能播放加密视频
  source : '你的视频播放地址',
  
  ```

  

* 设置播放凭证

  ```html
  encryptType:'1',//如果播放加密视频，则需设置encryptType=1，非加密视频无需设置此项
  vid : '视频id',
  playauth : '视频授权码',
  
  // 以下可选设置
  cover: 'http://guli.shop/photo/banner/1525939573202.jpg', // 封面
  qualitySort: 'asc', // 清晰度排序
  
  mediaType: 'video', // 返回音频还是视频
  autoplay: false, // 自动播放
  isLive: false, // 直播
  rePlay: false, // 循环播放
  preload: true,
  controlBarVisibility: 'hover', // 控制条的显示方式：鼠标悬停
  useH5Prism: true, // 播放器类型：html5
  
  ```

  

* mounted()：数据渲染之后执行

# 支付功能

* 生成订单接口

* 根据订单id查询订单信息

* 生成微信支付的二维码

  * 准备工作

    1. 微信支付id，商户号，商户key

  * 微信支付二维码接口

  * 引入依赖

    ```xml
    <dependencies>
        <dependency>
            <groupId>com.github.wxpay</groupId>
            <artifactId>wxpay-sdk</artifactId>
            <version>0.0.3</version>
        </dependency>
    
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
        </dependency>
    </dependencies>
    
    ```

  * 生成微信支付二维码的接口

    ```java
     public Map<String, Object> createWxQrcode(String orderNo) {
            try{
                //1、根据订单号查询订单信息
                QueryWrapper<TOrder> wrapper = new QueryWrapper<>();
                wrapper.eq("order_no",orderNo);
                TOrder tOrder = tOrderService.getOne(wrapper);
                
                //2、使用map来设置生成二维码需要的参数
                HashMap<String, String> map = new HashMap<>();
                map.put("appid","wx74862e0dfcf69954");//支付id
                map.put("mch_id", "1558950191");//商户号
                map.put("nonce_str", WXPayUtil.generateNonceStr());//生成随机的字符串，让每次生成的二维码不一样
                map.put("body", tOrder.getCourseTitle());//生成二维码的名字
                map.put("out_trade_no", orderNo);//二维码唯一的标识 
                map.put("total_fee", tOrder.getTotalFee().multiply(new BigDecimal("100")).longValue()+"");//支付金额
                map.put("spbill_create_ip", "127.0.0.1");//现在进行支付的ip地址，实际项目使用项目的域名
                map.put("notify_url", "http://guli.shop/api/order/weixinPay/weixinNotify");//支付后回调地址
                map.put("trade_type", "NATIVE");//支付类型，NATIVE:根据价格生成二维码
    
                //3、发送httpClient请求，传递参数【xml格式】，微信支付提供的固定地址
                HttpClient client = new HttpClient("https://api.mch.weixin.qq.com/pay/unifiedorder");
                //参数1：要转换为xml格式的map
                //参数2：商户的key，用于加密二维码中的信息
                client.setXmlParam(WXPayUtil.generateSignedXml(map,"T6m9iK73b0kn9g5v426MKfHQH7X8rKwb"));
                client.setHttps(true);//上面发送请求的是https。默认不支持，需要设置为true支持
                //执行post请求发送
                client.post();
    
                //4、得到发送请求返回的结果
                //返回的结果是xml格式的
                String content = client.getContent();
    
                //把xml格式转换为map集合，他里面的数据不全
                Map<String, String> resultMap = WXPayUtil.xmlToMap(content);
    
                //最终返回数据封装
                HashMap hashMap = new HashMap<>();
                hashMap.put("out_trade_no",orderNo);
                hashMap.put("course_id",tOrder.getCourseId());
                hashMap.put("total_fee",tOrder.getTotalFee());
                hashMap.put("result_code",resultMap.get("result_code")); //二维码操作状态码
                hashMap.put("code_url",resultMap.get("code_url")); //二维码地址
    
                //微信支付二维码2小时过期，可采取2小时未支付取消订单
                //redisTemplate.opsForValue().set(orderNo, hashMap, 120,TimeUnit.MINUTES);
    
                return hashMap;
    
    
            }catch (Exception e){
                e.printStackTrace();
                return null;
            }
    
        }
    ```

    

* 查询订单支付状态接口

# sql语句Date函数及取值

* date：获取日期时间格式里面日期部分

  ```sql
  select count(*) from ucenter_member uc where DATE(uc.gmt_create)='2020-2-2'
  ```

  

* 当获取多个参数时

  ```java
  Integer countRegister(String day,String day2);
  ```

  

  * 可以用索引,根据参数位置获取

    ```xml
         <select id="countRegister" resultType="java.lang.Integer">
    
             select count(*) from ucenter_member uc where DATE(uc.gmt_create)=#{0,1}
         </select>
    ```

  * 通过注解获取

    ```java
    Integer countRegister(@Param("aa")String day,@param("bb")String day2);
    ```

    ```xml
         <select id="countRegister" resultType="java.lang.Integer">
    
             select count(*) from ucenter_member uc where DATE(uc.gmt_create)=#{aa,bb}
         </select>
    ```

    

# 定时任务

* 定时任务：在固定时候自动执行程序，比如闹钟

* 步骤

  1. 在启动类添加注解

     ```java
     @EnableScheduling
     ```

  2. 创建定时任务类，在这个类中使用表达式设置什么时候执行

     * cron表达式：设置执行规则（七子表达式或七域表达式）

     ```java
     @Component
     public class ScheduledTask {
     
         //"0/5 * * * * ?"每隔5s执行一次这个方法
         @Scheduled(cron = "0/5 * * * * ?")
         public void task1(){
             System.out.println("====");
         }
     }
     ```

     

# echarts整合项目

* 步骤

  * 下载依赖

    `cnpm install --save echarts@4.1.0`
    
  * 导入
  
    `import echart from '@/echarts'`



# json对象

* map、对象：{"name":"lucy","age":"29"}
* list：[1,2,3]、["aa","bb","cc"]



# vue变量

* vue变量在当前作用域获取到，只能在当前作用域使用（vue在方法中得到变量，只能在方法中使用，外部获取不到）



# cannal数据同步工具

* 数据同步：将远程数据库中的内容同步到本地数据库

* 步骤

  * linux系统（创建数据库和数据表，名称和表结构一样）

    * 安装canal数据同步工具

  * window系统（创建数据库和数据表，名称和表结构一样）

  * 检查binlog功能是否有开启

    `show variables like 'log_bin';`

  * 修改 mysql 的配置文件 my.cnf

    ```vim
    追加内容：
    log-bin=mysql-bin     #binlog文件名
    binlog_format=ROW     #选择row模式
    server_id=1           #mysql实例id,不能和canal的slaveId重复
    ```

  * 安装canal

    * 上传linux系统

    * 解压

    * 修改canal配置文件conf/example/instance.properties

      ```properties
      #需要改成自己的数据库信息
      canal.instance.master.address=192.168.44.132:3306
      
      #需要改成自己的数据库用户名与密码
      
      canal.instance.dbUsername=canal
      canal.instance.dbPassword=canal
      
      #需要改成同步的数据库表规则，例如只是同步一下表
      #canal.instance.filter.regex=.*\\..*
      canal.instance.filter.regex=guli_ucenter.ucenter_member
      
      ```

    * 启动canal

# GateWay

* 网关：在客户端和服务端中间的一面墙，可以起到作用有很多：比如请求转发，负载均衡，权限控制等

  * 路由：对应不同的服务名
  * 断言：匹配规则
  * 过滤器：对请求或响应做处理

* 具体使用

  * 引入相关依赖
  * 创建启动类，创建配置文件，在配置文件中配置网关规则

  ```properties
  # 服务端口
  server.port=8222
  # 服务名
  spring.application.name=service-gateway
  
  # nacos服务地址
  spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
  
  #使用服务发现路由
  spring.cloud.gateway.discovery.locator.enabled=true
  
  #设置路由id
  spring.cloud.gateway.routes[0].id=service-acl
  #设置路由的uri lb://在nacos注册的服务名称
  spring.cloud.gateway.routes[0].uri=lb://service-acl
  #设置路由断言,代理servicerId为auth-service的/auth/路径
  spring.cloud.gateway.routes[0].predicates= Path=/*/acl/**
  
  
  #配置service-edu服务
  spring.cloud.gateway.routes[1].id=service-edu
  spring.cloud.gateway.routes[1].uri=lb://service-edu
  spring.cloud.gateway.routes[1].predicates= Path=/eduservice/**
  ```

  

# 递归

* 递归操作需要找到查询入口
  * 入口就是顶级菜单
  
    ```java
      //把返回所有菜单list集合进行封装的方法
        public static List<Permission> bulidPermission(List<Permission> permissionList) {
    
            //创建list集合，用于数据最终封装
            List<Permission> finalNode = new ArrayList<>();
            //把所有菜单list集合遍历，得到顶层菜单 pid=0菜单，设置level是1
            for(Permission permissionNode : permissionList) {
                //得到顶层菜单 pid=0菜单
                if("0".equals(permissionNode.getPid())) {
                    //设置顶层菜单的level是1
                    permissionNode.setLevel(1);
                    //根据顶层菜单，向里面进行查询子菜单，封装到finalNode里面
                    finalNode.add(selectChildren(permissionNode,permissionList));
                }
            }
            return finalNode;
        }
    
        private static Permission selectChildren(Permission permissionNode, List<Permission> permissionList) {
            //1 因为向一层菜单里面放二层菜单，二层里面还要放三层，把对象初始化
            permissionNode.setChildren(new ArrayList<Permission>());
    
            //2 遍历所有菜单list集合，进行判断比较，比较id和pid值是否相同
            for(Permission it : permissionList) {
                //判断 id和pid值是否相同
                if(permissionNode.getId().equals(it.getPid())) {
                    //把父菜单的level值+1
                    int level = permissionNode.getLevel()+1;
                    it.setLevel(level);
                    //如果children为空，进行初始化操作
                    if(permissionNode.getChildren() == null) {
                        permissionNode.setChildren(new ArrayList<Permission>());
                    }
                    //把查询出来的子菜单放到父菜单里面
                    permissionNode.getChildren().add(selectChildren(it,permissionList));
                }
            }
            return permissionNode;
        }
    
    ```
  
    

# Spring Security

* Spring Security 主要包含有两部分：用户认证和用户授权
  * 用户认证：进入用户登录时，输入用户名和密码，查询数据库，输入用户名和密码上是否正确，如果正确，认证成功
  * 用户授权：登录了系统，登录用户可能时不同的角色，比如登录的用户是管理员，管理员操作所有功能，比如登录用户、普通用户操作功能肯定比管理员少
* Spring Security本质上就是过滤器Filter，对请求进行过滤



* 步骤
  * 登录用户名和密码，查询登录用户权限列表
  * 存入redis 
    * key：登录成功用户名
    * value：用户权限列表
  * token
  * token放到cookie在header放token值
  * 从header获取token，从token获取用户名拿着用户名从redis获取权限列表
  * 有spring security给当前用户赋予权限，可以进行相应操作

# git提交idea

* file->settings->git配置安装目录
* vcs->create git repository
* 右击项目，选择git，添加项目代码
* 设置远程git 仓库地址
  * 设置码云地址
* git->commit directory
* share project on github
  * 设置已有仓库就不用share
    * git->Repository->Remotes
    * git->Repository->push
* 本地库和远程库断开连接
  * file->version Control
  * 找到项目文件夹路径，删除.git文件夹 



* idea中项目发生更改
  * 需要先add
  * commit directory
  * push

# nacos配置中心

* 新建配置
  * Data ID 的完整规则格式如下**${prefix}-${spring.profile.active}.${file-extension}**
    *  **prefix** ：服务名称
    *  **spring.profiles.active=dev** ：spring.profiles.active的值，如果在配置文件中没有设置，值为空
    *  **file-exetension** ：配置文件类型
  * 创建bootstrap.properties文件



* springboot配置文件加载顺序
  * bootstrap.properties
  * applicatin.properties
    * spring.profiles.active=dev
  * application-dev.properties
  
* 项目几种开发环境
  * dev：开发环境
  * test：测试环境
  * prod：生产环境

* 命名空间

  * 新建命名空间

  * 在不同的名称空间里创建配置文件

  * 修改配置文件

    ```properties
    spring.cloud.nacos.config.namespace=925a4338-5327-4967-8720-65412f8fc0df
    
    ```

* 多配置文件加载

  * bootstrap

  ```properties
  spring.cloud.nacos.config.ext-config[0].data-id=port.properties
   #开启动态刷新配置，否则配置文件，工程无法感知
  spring.cloud.nacos.config.ext-config[0].refresh=true
  ```

  

# jenkins

* 持续化部署工具